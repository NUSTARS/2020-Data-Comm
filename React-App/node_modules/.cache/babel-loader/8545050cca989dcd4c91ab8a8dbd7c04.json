{"ast":null,"code":"const {\n  Transform\n} = require('stream');\n/**\n * A transform stream that emits data each time a byte sequence is received.\n * @extends Transform\n * @summary To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.\n * @example\nconst SerialPort = require('serialport')\nconst Delimiter = require('@serialport/parser-delimiter')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Delimiter({ delimiter: '\\n' }))\nparser.on('data', console.log)\n */\n\n\nclass DelimiterParser extends Transform {\n  constructor(options = {}) {\n    super(options);\n\n    if (options.delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object');\n    }\n\n    if (options.delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length');\n    }\n\n    this.includeDelimiter = options.includeDelimiter !== undefined ? options.includeDelimiter : false;\n    this.delimiter = Buffer.from(options.delimiter);\n    this.buffer = Buffer.alloc(0);\n  }\n\n  _transform(chunk, encoding, cb) {\n    let data = Buffer.concat([this.buffer, chunk]);\n    let position;\n\n    while ((position = data.indexOf(this.delimiter)) !== -1) {\n      this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));\n      data = data.slice(position + this.delimiter.length);\n    }\n\n    this.buffer = data;\n    cb();\n  }\n\n  _flush(cb) {\n    this.push(this.buffer);\n    this.buffer = Buffer.alloc(0);\n    cb();\n  }\n\n}\n\nmodule.exports = DelimiterParser;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/parser-delimiter/lib/index.js"],"names":["Transform","require","DelimiterParser","constructor","options","delimiter","undefined","TypeError","length","includeDelimiter","Buffer","from","buffer","alloc","_transform","chunk","encoding","cb","data","concat","position","indexOf","push","slice","_flush","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;AAEA;;;;;;;;;;;;;AAWA,MAAMC,eAAN,SAA8BF,SAA9B,CAAwC;AACtCG,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB,UAAMA,OAAN;;AAEA,QAAIA,OAAO,CAACC,SAAR,KAAsBC,SAA1B,EAAqC;AACnC,YAAM,IAAIC,SAAJ,CAAc,wCAAd,CAAN;AACD;;AAED,QAAIH,OAAO,CAACC,SAAR,CAAkBG,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,YAAM,IAAID,SAAJ,CAAc,yCAAd,CAAN;AACD;;AAED,SAAKE,gBAAL,GAAwBL,OAAO,CAACK,gBAAR,KAA6BH,SAA7B,GAAyCF,OAAO,CAACK,gBAAjD,GAAoE,KAA5F;AACA,SAAKJ,SAAL,GAAiBK,MAAM,CAACC,IAAP,CAAYP,OAAO,CAACC,SAApB,CAAjB;AACA,SAAKO,MAAL,GAAcF,MAAM,CAACG,KAAP,CAAa,CAAb,CAAd;AACD;;AAEDC,EAAAA,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,EAAlB,EAAsB;AAC9B,QAAIC,IAAI,GAAGR,MAAM,CAACS,MAAP,CAAc,CAAC,KAAKP,MAAN,EAAcG,KAAd,CAAd,CAAX;AACA,QAAIK,QAAJ;;AACA,WAAO,CAACA,QAAQ,GAAGF,IAAI,CAACG,OAAL,CAAa,KAAKhB,SAAlB,CAAZ,MAA8C,CAAC,CAAtD,EAAyD;AACvD,WAAKiB,IAAL,CAAUJ,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,QAAQ,IAAI,KAAKX,gBAAL,GAAwB,KAAKJ,SAAL,CAAeG,MAAvC,GAAgD,CAApD,CAAtB,CAAV;AACAU,MAAAA,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAWH,QAAQ,GAAG,KAAKf,SAAL,CAAeG,MAArC,CAAP;AACD;;AACD,SAAKI,MAAL,GAAcM,IAAd;AACAD,IAAAA,EAAE;AACH;;AAEDO,EAAAA,MAAM,CAACP,EAAD,EAAK;AACT,SAAKK,IAAL,CAAU,KAAKV,MAAf;AACA,SAAKA,MAAL,GAAcF,MAAM,CAACG,KAAP,CAAa,CAAb,CAAd;AACAI,IAAAA,EAAE;AACH;;AAhCqC;;AAmCxCQ,MAAM,CAACC,OAAP,GAAiBxB,eAAjB","sourcesContent":["const { Transform } = require('stream')\n\n/**\n * A transform stream that emits data each time a byte sequence is received.\n * @extends Transform\n * @summary To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.\n * @example\nconst SerialPort = require('serialport')\nconst Delimiter = require('@serialport/parser-delimiter')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Delimiter({ delimiter: '\\n' }))\nparser.on('data', console.log)\n */\nclass DelimiterParser extends Transform {\n  constructor(options = {}) {\n    super(options)\n\n    if (options.delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object')\n    }\n\n    if (options.delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length')\n    }\n\n    this.includeDelimiter = options.includeDelimiter !== undefined ? options.includeDelimiter : false\n    this.delimiter = Buffer.from(options.delimiter)\n    this.buffer = Buffer.alloc(0)\n  }\n\n  _transform(chunk, encoding, cb) {\n    let data = Buffer.concat([this.buffer, chunk])\n    let position\n    while ((position = data.indexOf(this.delimiter)) !== -1) {\n      this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)))\n      data = data.slice(position + this.delimiter.length)\n    }\n    this.buffer = data\n    cb()\n  }\n\n  _flush(cb) {\n    this.push(this.buffer)\n    this.buffer = Buffer.alloc(0)\n    cb()\n  }\n}\n\nmodule.exports = DelimiterParser\n"]},"metadata":{},"sourceType":"script"}