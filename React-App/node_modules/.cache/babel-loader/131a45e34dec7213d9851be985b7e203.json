{"ast":null,"code":"const {\n  Transform\n} = require('stream');\n/**\n * A transform stream that uses a regular expression to split the incoming text upon.\n *\n * To use the `Regex` parser provide a regular expression to split the incoming text upon. Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n * @extends Transform\n * @example\nconst SerialPort = require('serialport')\nconst Regex = require('@serialport/parser-regex')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Regex({ regex: /[\\r\\n]+/ }))\nparser.on('data', console.log)\n */\n\n\nclass RegexParser extends Transform {\n  constructor(options) {\n    const opts = {\n      encoding: 'utf8',\n      ...options\n    };\n\n    if (opts.regex === undefined) {\n      throw new TypeError('\"options.regex\" must be a regular expression pattern or object');\n    }\n\n    if (!(opts.regex instanceof RegExp)) {\n      opts.regex = new RegExp(opts.regex);\n    }\n\n    super(opts);\n    this.regex = opts.regex;\n    this.data = '';\n  }\n\n  _transform(chunk, encoding, cb) {\n    const data = this.data + chunk;\n    const parts = data.split(this.regex);\n    this.data = parts.pop();\n    parts.forEach(part => {\n      this.push(part);\n    });\n    cb();\n  }\n\n  _flush(cb) {\n    this.push(this.data);\n    this.data = '';\n    cb();\n  }\n\n}\n\nmodule.exports = RegexParser;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/parser-regex/lib/index.js"],"names":["Transform","require","RegexParser","constructor","options","opts","encoding","regex","undefined","TypeError","RegExp","data","_transform","chunk","cb","parts","split","pop","forEach","part","push","_flush","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;AAEA;;;;;;;;;;;;;;AAYA,MAAMC,WAAN,SAA0BF,SAA1B,CAAoC;AAClCG,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMC,IAAI,GAAG;AACXC,MAAAA,QAAQ,EAAE,MADC;AAEX,SAAGF;AAFQ,KAAb;;AAKA,QAAIC,IAAI,CAACE,KAAL,KAAeC,SAAnB,EAA8B;AAC5B,YAAM,IAAIC,SAAJ,CAAc,gEAAd,CAAN;AACD;;AAED,QAAI,EAAEJ,IAAI,CAACE,KAAL,YAAsBG,MAAxB,CAAJ,EAAqC;AACnCL,MAAAA,IAAI,CAACE,KAAL,GAAa,IAAIG,MAAJ,CAAWL,IAAI,CAACE,KAAhB,CAAb;AACD;;AACD,UAAMF,IAAN;AAEA,SAAKE,KAAL,GAAaF,IAAI,CAACE,KAAlB;AACA,SAAKI,IAAL,GAAY,EAAZ;AACD;;AAEDC,EAAAA,UAAU,CAACC,KAAD,EAAQP,QAAR,EAAkBQ,EAAlB,EAAsB;AAC9B,UAAMH,IAAI,GAAG,KAAKA,IAAL,GAAYE,KAAzB;AACA,UAAME,KAAK,GAAGJ,IAAI,CAACK,KAAL,CAAW,KAAKT,KAAhB,CAAd;AACA,SAAKI,IAAL,GAAYI,KAAK,CAACE,GAAN,EAAZ;AAEAF,IAAAA,KAAK,CAACG,OAAN,CAAcC,IAAI,IAAI;AACpB,WAAKC,IAAL,CAAUD,IAAV;AACD,KAFD;AAGAL,IAAAA,EAAE;AACH;;AAEDO,EAAAA,MAAM,CAACP,EAAD,EAAK;AACT,SAAKM,IAAL,CAAU,KAAKT,IAAf;AACA,SAAKA,IAAL,GAAY,EAAZ;AACAG,IAAAA,EAAE;AACH;;AAnCiC;;AAsCpCQ,MAAM,CAACC,OAAP,GAAiBrB,WAAjB","sourcesContent":["const { Transform } = require('stream')\n\n/**\n * A transform stream that uses a regular expression to split the incoming text upon.\n *\n * To use the `Regex` parser provide a regular expression to split the incoming text upon. Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).\n * @extends Transform\n * @example\nconst SerialPort = require('serialport')\nconst Regex = require('@serialport/parser-regex')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Regex({ regex: /[\\r\\n]+/ }))\nparser.on('data', console.log)\n */\nclass RegexParser extends Transform {\n  constructor(options) {\n    const opts = {\n      encoding: 'utf8',\n      ...options,\n    }\n\n    if (opts.regex === undefined) {\n      throw new TypeError('\"options.regex\" must be a regular expression pattern or object')\n    }\n\n    if (!(opts.regex instanceof RegExp)) {\n      opts.regex = new RegExp(opts.regex)\n    }\n    super(opts)\n\n    this.regex = opts.regex\n    this.data = ''\n  }\n\n  _transform(chunk, encoding, cb) {\n    const data = this.data + chunk\n    const parts = data.split(this.regex)\n    this.data = parts.pop()\n\n    parts.forEach(part => {\n      this.push(part)\n    })\n    cb()\n  }\n\n  _flush(cb) {\n    this.push(this.data)\n    this.data = ''\n    cb()\n  }\n}\n\nmodule.exports = RegexParser\n"]},"metadata":{},"sourceType":"script"}