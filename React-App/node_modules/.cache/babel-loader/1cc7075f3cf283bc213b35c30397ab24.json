{"ast":null,"code":"const debug = require('debug');\n\nconst logger = debug('serialport/bindings/poller');\n\nconst EventEmitter = require('events');\n\nconst PollerBindings = require('bindings')('bindings.node').Poller;\n\nconst EVENTS = {\n  UV_READABLE: 0b0001,\n  UV_WRITABLE: 0b0010,\n  UV_DISCONNECT: 0b0100\n};\n\nfunction handleEvent(error, eventFlag) {\n  if (error) {\n    logger('error', error);\n    this.emit('readable', error);\n    this.emit('writable', error);\n    this.emit('disconnect', error);\n    return;\n  }\n\n  if (eventFlag & EVENTS.UV_READABLE) {\n    logger('received \"readable\"');\n    this.emit('readable', null);\n  }\n\n  if (eventFlag & EVENTS.UV_WRITABLE) {\n    logger('received \"writable\"');\n    this.emit('writable', null);\n  }\n\n  if (eventFlag & EVENTS.UV_DISCONNECT) {\n    logger('received \"disconnect\"');\n    this.emit('disconnect', null);\n  }\n}\n/**\n * Polls unix systems for readable or writable states of a file or serialport\n */\n\n\nclass Poller extends EventEmitter {\n  constructor(fd, FDPoller = PollerBindings) {\n    logger('Creating poller');\n    super();\n    this.poller = new FDPoller(fd, handleEvent.bind(this));\n  }\n  /**\n   * Wait for the next event to occur\n   * @param {string} event ('readable'|'writable'|'disconnect')\n   * @returns {Poller} returns itself\n   */\n\n\n  once(event, callback) {\n    switch (event) {\n      case 'readable':\n        this.poll(EVENTS.UV_READABLE);\n        break;\n\n      case 'writable':\n        this.poll(EVENTS.UV_WRITABLE);\n        break;\n\n      case 'disconnect':\n        this.poll(EVENTS.UV_DISCONNECT);\n        break;\n    }\n\n    return super.once(event, callback);\n  }\n  /**\n   * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use\n   * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.\n   * @returns {undefined}\n   */\n\n\n  poll(eventFlag) {\n    eventFlag = eventFlag || 0;\n\n    if (eventFlag & EVENTS.UV_READABLE) {\n      logger('Polling for \"readable\"');\n    }\n\n    if (eventFlag & EVENTS.UV_WRITABLE) {\n      logger('Polling for \"writable\"');\n    }\n\n    if (eventFlag & EVENTS.UV_DISCONNECT) {\n      logger('Polling for \"disconnect\"');\n    }\n\n    this.poller.poll(eventFlag);\n  }\n  /**\n   * Stop listening for events and cancel all outstanding listening with an error\n   * @returns {undefined}\n   */\n\n\n  stop() {\n    logger('Stopping poller');\n    this.poller.stop();\n    this.emitCanceled();\n  }\n\n  destroy() {\n    logger('Destroying poller');\n    this.poller.destroy();\n    this.emitCanceled();\n  }\n\n  emitCanceled() {\n    const err = new Error('Canceled');\n    err.canceled = true;\n    this.emit('readable', err);\n    this.emit('writable', err);\n    this.emit('disconnect', err);\n  }\n\n}\n\nPoller.EVENTS = EVENTS;\nmodule.exports = Poller;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/bindings/lib/poller.js"],"names":["debug","require","logger","EventEmitter","PollerBindings","Poller","EVENTS","UV_READABLE","UV_WRITABLE","UV_DISCONNECT","handleEvent","error","eventFlag","emit","constructor","fd","FDPoller","poller","bind","once","event","callback","poll","stop","emitCanceled","destroy","err","Error","canceled","module","exports"],"mappings":"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","sourcesContent":["const debug = require('debug')\nconst logger = debug('serialport/bindings/poller')\nconst EventEmitter = require('events')\nconst PollerBindings = require('bindings')('bindings.node').Poller\n\nconst EVENTS = {\n  UV_READABLE: 0b0001,\n  UV_WRITABLE: 0b0010,\n  UV_DISCONNECT: 0b0100,\n}\n\nfunction handleEvent(error, eventFlag) {\n  if (error) {\n    logger('error', error)\n    this.emit('readable', error)\n    this.emit('writable', error)\n    this.emit('disconnect', error)\n    return\n  }\n  if (eventFlag & EVENTS.UV_READABLE) {\n    logger('received \"readable\"')\n    this.emit('readable', null)\n  }\n  if (eventFlag & EVENTS.UV_WRITABLE) {\n    logger('received \"writable\"')\n    this.emit('writable', null)\n  }\n  if (eventFlag & EVENTS.UV_DISCONNECT) {\n    logger('received \"disconnect\"')\n    this.emit('disconnect', null)\n  }\n}\n\n/**\n * Polls unix systems for readable or writable states of a file or serialport\n */\nclass Poller extends EventEmitter {\n  constructor(fd, FDPoller = PollerBindings) {\n    logger('Creating poller')\n    super()\n    this.poller = new FDPoller(fd, handleEvent.bind(this))\n  }\n  /**\n   * Wait for the next event to occur\n   * @param {string} event ('readable'|'writable'|'disconnect')\n   * @returns {Poller} returns itself\n   */\n  once(event, callback) {\n    switch (event) {\n      case 'readable':\n        this.poll(EVENTS.UV_READABLE)\n        break\n      case 'writable':\n        this.poll(EVENTS.UV_WRITABLE)\n        break\n      case 'disconnect':\n        this.poll(EVENTS.UV_DISCONNECT)\n        break\n    }\n    return super.once(event, callback)\n  }\n\n  /**\n   * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use\n   * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.\n   * @returns {undefined}\n   */\n  poll(eventFlag) {\n    eventFlag = eventFlag || 0\n\n    if (eventFlag & EVENTS.UV_READABLE) {\n      logger('Polling for \"readable\"')\n    }\n    if (eventFlag & EVENTS.UV_WRITABLE) {\n      logger('Polling for \"writable\"')\n    }\n    if (eventFlag & EVENTS.UV_DISCONNECT) {\n      logger('Polling for \"disconnect\"')\n    }\n\n    this.poller.poll(eventFlag)\n  }\n\n  /**\n   * Stop listening for events and cancel all outstanding listening with an error\n   * @returns {undefined}\n   */\n  stop() {\n    logger('Stopping poller')\n    this.poller.stop()\n    this.emitCanceled()\n  }\n\n  destroy() {\n    logger('Destroying poller')\n    this.poller.destroy()\n    this.emitCanceled()\n  }\n\n  emitCanceled() {\n    const err = new Error('Canceled')\n    err.canceled = true\n    this.emit('readable', err)\n    this.emit('writable', err)\n    this.emit('disconnect', err)\n  }\n}\n\nPoller.EVENTS = EVENTS\n\nmodule.exports = Poller\n"]},"metadata":{},"sourceType":"script"}