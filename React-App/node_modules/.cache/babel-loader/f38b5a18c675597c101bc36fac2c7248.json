{"ast":null,"code":"const fs = require('fs');\n\nconst debug = require('debug');\n\nconst logger = debug('serialport/bindings/unixWrite');\n\nconst {\n  promisify\n} = require('util');\n\nconst writeAsync = promisify(fs.write);\n\nconst writable = binding => {\n  return new Promise((resolve, reject) => {\n    binding.poller.once('writable', err => err ? reject(err) : resolve());\n  });\n};\n\nconst unixWrite = async ({\n  binding,\n  buffer,\n  offset = 0,\n  fsWriteAsync = writeAsync\n}) => {\n  const bytesToWrite = buffer.length - offset;\n  logger('Starting write', buffer.length, 'bytes offset', offset, 'bytesToWrite', bytesToWrite);\n\n  if (!binding.isOpen) {\n    throw new Error('Port is not open');\n  }\n\n  try {\n    const {\n      bytesWritten\n    } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite);\n    logger('write returned: wrote', bytesWritten, 'bytes');\n\n    if (bytesWritten + offset < buffer.length) {\n      if (!binding.isOpen) {\n        throw new Error('Port is not open');\n      }\n\n      return unixWrite({\n        binding,\n        buffer,\n        offset: bytesWritten + offset,\n        fsWriteAsync\n      });\n    }\n\n    logger('Finished writing', bytesWritten + offset, 'bytes');\n  } catch (err) {\n    logger('write errored', err);\n\n    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n      if (!binding.isOpen) {\n        throw new Error('Port is not open');\n      }\n\n      logger('waiting for writable because of code:', err.code);\n      await writable(binding);\n      return unixWrite({\n        binding,\n        buffer,\n        offset,\n        fsWriteAsync\n      });\n    }\n\n    const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n    err.code === 'ENXIO' || // No such device or address probably usb disconnect\n    err.code === 'UNKNOWN' || err.errno === -1; // generic error\n\n    if (disconnectError) {\n      err.disconnect = true;\n      logger('disconnecting', err);\n    }\n\n    logger('error', err);\n    throw err;\n  }\n};\n\nmodule.exports = unixWrite;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/bindings/lib/unix-write.js"],"names":["fs","require","debug","logger","promisify","writeAsync","write","writable","binding","Promise","resolve","reject","poller","once","err","unixWrite","buffer","offset","fsWriteAsync","bytesToWrite","length","isOpen","Error","bytesWritten","fd","code","disconnectError","errno","disconnect","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs')\nconst debug = require('debug')\nconst logger = debug('serialport/bindings/unixWrite')\nconst { promisify } = require('util')\n\nconst writeAsync = promisify(fs.write)\n\nconst writable = binding => {\n  return new Promise((resolve, reject) => {\n    binding.poller.once('writable', err => (err ? reject(err) : resolve()))\n  })\n}\n\nconst unixWrite = async ({ binding, buffer, offset = 0, fsWriteAsync = writeAsync }) => {\n  const bytesToWrite = buffer.length - offset\n  logger('Starting write', buffer.length, 'bytes offset', offset, 'bytesToWrite', bytesToWrite)\n  if (!binding.isOpen) {\n    throw new Error('Port is not open')\n  }\n  try {\n    const { bytesWritten } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite)\n    logger('write returned: wrote', bytesWritten, 'bytes')\n    if (bytesWritten + offset < buffer.length) {\n      if (!binding.isOpen) {\n        throw new Error('Port is not open')\n      }\n      return unixWrite({ binding, buffer, offset: bytesWritten + offset, fsWriteAsync })\n    }\n\n    logger('Finished writing', bytesWritten + offset, 'bytes')\n  } catch (err) {\n    logger('write errored', err)\n    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n      if (!binding.isOpen) {\n        throw new Error('Port is not open')\n      }\n      logger('waiting for writable because of code:', err.code)\n      await writable(binding)\n      return unixWrite({ binding, buffer, offset, fsWriteAsync })\n    }\n\n    const disconnectError =\n      err.code === 'EBADF' || // Bad file number means we got closed\n      err.code === 'ENXIO' || // No such device or address probably usb disconnect\n      err.code === 'UNKNOWN' ||\n      err.errno === -1 // generic error\n\n    if (disconnectError) {\n      err.disconnect = true\n      logger('disconnecting', err)\n    }\n\n    logger('error', err)\n    throw err\n  }\n}\nmodule.exports = unixWrite\n"]},"metadata":{},"sourceType":"script"}