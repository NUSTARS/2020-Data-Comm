{"ast":null,"code":"const {\n  Transform\n} = require('stream');\n/**\n * Emit data every number of bytes\n * @extends Transform\n * @param {Object} options parser options object\n * @param {Number} options.length the number of bytes on each data event\n * @summary A transform stream that emits data as a buffer after a specific number of bytes are received. Runs in O(n) time.\n * @example\nconst SerialPort = require('serialport')\nconst ByteLength = require('@serialport/parser-byte-length')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new ByteLength({length: 8}))\nparser.on('data', console.log) // will have 8 bytes per data event\n */\n\n\nclass ByteLengthParser extends Transform {\n  constructor(options = {}) {\n    super(options);\n\n    if (typeof options.length !== 'number') {\n      throw new TypeError('\"length\" is not a number');\n    }\n\n    if (options.length < 1) {\n      throw new TypeError('\"length\" is not greater than 0');\n    }\n\n    this.length = options.length;\n    this.position = 0;\n    this.buffer = Buffer.alloc(this.length);\n  }\n\n  _transform(chunk, encoding, cb) {\n    let cursor = 0;\n\n    while (cursor < chunk.length) {\n      this.buffer[this.position] = chunk[cursor];\n      cursor++;\n      this.position++;\n\n      if (this.position === this.length) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(this.length);\n        this.position = 0;\n      }\n    }\n\n    cb();\n  }\n\n  _flush(cb) {\n    this.push(this.buffer.slice(0, this.position));\n    this.buffer = Buffer.alloc(this.length);\n    cb();\n  }\n\n}\n\nmodule.exports = ByteLengthParser;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/parser-byte-length/lib/index.js"],"names":["Transform","require","ByteLengthParser","constructor","options","length","TypeError","position","buffer","Buffer","alloc","_transform","chunk","encoding","cb","cursor","push","_flush","slice","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;AAEA;;;;;;;;;;;;;;;AAaA,MAAMC,gBAAN,SAA+BF,SAA/B,CAAyC;AACvCG,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB,UAAMA,OAAN;;AAEA,QAAI,OAAOA,OAAO,CAACC,MAAf,KAA0B,QAA9B,EAAwC;AACtC,YAAM,IAAIC,SAAJ,CAAc,0BAAd,CAAN;AACD;;AAED,QAAIF,OAAO,CAACC,MAAR,GAAiB,CAArB,EAAwB;AACtB,YAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACD;;AAED,SAAKD,MAAL,GAAcD,OAAO,CAACC,MAAtB;AACA,SAAKE,QAAL,GAAgB,CAAhB;AACA,SAAKC,MAAL,GAAcC,MAAM,CAACC,KAAP,CAAa,KAAKL,MAAlB,CAAd;AACD;;AAEDM,EAAAA,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,EAAlB,EAAsB;AAC9B,QAAIC,MAAM,GAAG,CAAb;;AACA,WAAOA,MAAM,GAAGH,KAAK,CAACP,MAAtB,EAA8B;AAC5B,WAAKG,MAAL,CAAY,KAAKD,QAAjB,IAA6BK,KAAK,CAACG,MAAD,CAAlC;AACAA,MAAAA,MAAM;AACN,WAAKR,QAAL;;AACA,UAAI,KAAKA,QAAL,KAAkB,KAAKF,MAA3B,EAAmC;AACjC,aAAKW,IAAL,CAAU,KAAKR,MAAf;AACA,aAAKA,MAAL,GAAcC,MAAM,CAACC,KAAP,CAAa,KAAKL,MAAlB,CAAd;AACA,aAAKE,QAAL,GAAgB,CAAhB;AACD;AACF;;AACDO,IAAAA,EAAE;AACH;;AAEDG,EAAAA,MAAM,CAACH,EAAD,EAAK;AACT,SAAKE,IAAL,CAAU,KAAKR,MAAL,CAAYU,KAAZ,CAAkB,CAAlB,EAAqB,KAAKX,QAA1B,CAAV;AACA,SAAKC,MAAL,GAAcC,MAAM,CAACC,KAAP,CAAa,KAAKL,MAAlB,CAAd;AACAS,IAAAA,EAAE;AACH;;AApCsC;;AAuCzCK,MAAM,CAACC,OAAP,GAAiBlB,gBAAjB","sourcesContent":["const { Transform } = require('stream')\n\n/**\n * Emit data every number of bytes\n * @extends Transform\n * @param {Object} options parser options object\n * @param {Number} options.length the number of bytes on each data event\n * @summary A transform stream that emits data as a buffer after a specific number of bytes are received. Runs in O(n) time.\n * @example\nconst SerialPort = require('serialport')\nconst ByteLength = require('@serialport/parser-byte-length')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new ByteLength({length: 8}))\nparser.on('data', console.log) // will have 8 bytes per data event\n */\nclass ByteLengthParser extends Transform {\n  constructor(options = {}) {\n    super(options)\n\n    if (typeof options.length !== 'number') {\n      throw new TypeError('\"length\" is not a number')\n    }\n\n    if (options.length < 1) {\n      throw new TypeError('\"length\" is not greater than 0')\n    }\n\n    this.length = options.length\n    this.position = 0\n    this.buffer = Buffer.alloc(this.length)\n  }\n\n  _transform(chunk, encoding, cb) {\n    let cursor = 0\n    while (cursor < chunk.length) {\n      this.buffer[this.position] = chunk[cursor]\n      cursor++\n      this.position++\n      if (this.position === this.length) {\n        this.push(this.buffer)\n        this.buffer = Buffer.alloc(this.length)\n        this.position = 0\n      }\n    }\n    cb()\n  }\n\n  _flush(cb) {\n    this.push(this.buffer.slice(0, this.position))\n    this.buffer = Buffer.alloc(this.length)\n    cb()\n  }\n}\n\nmodule.exports = ByteLengthParser\n"]},"metadata":{},"sourceType":"script"}