{"ast":null,"code":"const childProcess = require('child_process');\n\nconst Readline = require('@serialport/parser-readline'); // get only serial port names\n\n\nfunction checkPathOfDevice(path) {\n  return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path) && path;\n}\n\nfunction propName(name) {\n  return {\n    DEVNAME: 'path',\n    ID_VENDOR_ENC: 'manufacturer',\n    ID_SERIAL_SHORT: 'serialNumber',\n    ID_VENDOR_ID: 'vendorId',\n    ID_MODEL_ID: 'productId',\n    DEVLINKS: 'pnpId'\n  }[name.toUpperCase()];\n}\n\nfunction decodeHexEscape(str) {\n  return str.replace(/\\\\x([a-fA-F0-9]{2})/g, (a, b) => {\n    return String.fromCharCode(parseInt(b, 16));\n  });\n}\n\nfunction propVal(name, val) {\n  if (name === 'pnpId') {\n    const match = val.match(/\\/by-id\\/([^\\s]+)/);\n    return match && match[1] || undefined;\n  }\n\n  if (name === 'manufacturer') {\n    return decodeHexEscape(val);\n  }\n\n  if (/^0x/.test(val)) {\n    return val.substr(2);\n  }\n\n  return val;\n}\n\nfunction listLinux() {\n  return new Promise((resolve, reject) => {\n    const ports = [];\n    const ude = childProcess.spawn('udevadm', ['info', '-e']);\n    const lines = ude.stdout.pipe(new Readline());\n    ude.on('close', code => code && reject(new Error(`Error listing ports udevadm exited with error code: ${code}`)));\n    ude.on('error', reject);\n    lines.on('error', reject);\n    let port = {};\n    let skipPort = false;\n    lines.on('data', line => {\n      const lineType = line.slice(0, 1);\n      const data = line.slice(3); // new port entry\n\n      if (lineType === 'P') {\n        port = {\n          manufacturer: undefined,\n          serialNumber: undefined,\n          pnpId: undefined,\n          locationId: undefined,\n          vendorId: undefined,\n          productId: undefined\n        };\n        skipPort = false;\n        return;\n      }\n\n      if (skipPort) {\n        return;\n      } // Check dev name and save port if it matches flag to skip the rest of the data if not\n\n\n      if (lineType === 'N') {\n        if (checkPathOfDevice(data)) {\n          ports.push(port);\n        } else {\n          skipPort = true;\n        }\n\n        return;\n      } // parse data about each port\n\n\n      if (lineType === 'E') {\n        const keyValue = data.match(/^(.+)=(.*)/);\n\n        if (!keyValue) {\n          return;\n        }\n\n        const key = propName(keyValue[1]);\n\n        if (!key) {\n          return;\n        }\n\n        port[key] = propVal(key, keyValue[2]);\n      }\n    });\n    lines.on('finish', () => resolve(ports));\n  });\n}\n\nmodule.exports = listLinux;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/bindings/lib/linux-list.js"],"names":["childProcess","require","Readline","checkPathOfDevice","path","test","propName","name","DEVNAME","ID_VENDOR_ENC","ID_SERIAL_SHORT","ID_VENDOR_ID","ID_MODEL_ID","DEVLINKS","toUpperCase","decodeHexEscape","str","replace","a","b","String","fromCharCode","parseInt","propVal","val","match","undefined","substr","listLinux","Promise","resolve","reject","ports","ude","spawn","lines","stdout","pipe","on","code","Error","port","skipPort","line","lineType","slice","data","manufacturer","serialNumber","pnpId","locationId","vendorId","productId","push","keyValue","key","module","exports"],"mappings":"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","sourcesContent":["const childProcess = require('child_process')\nconst Readline = require('@serialport/parser-readline')\n\n// get only serial port names\nfunction checkPathOfDevice(path) {\n  return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path) && path\n}\n\nfunction propName(name) {\n  return {\n    DEVNAME: 'path',\n    ID_VENDOR_ENC: 'manufacturer',\n    ID_SERIAL_SHORT: 'serialNumber',\n    ID_VENDOR_ID: 'vendorId',\n    ID_MODEL_ID: 'productId',\n    DEVLINKS: 'pnpId',\n  }[name.toUpperCase()]\n}\n\nfunction decodeHexEscape(str) {\n  return str.replace(/\\\\x([a-fA-F0-9]{2})/g, (a, b) => {\n    return String.fromCharCode(parseInt(b, 16))\n  })\n}\n\nfunction propVal(name, val) {\n  if (name === 'pnpId') {\n    const match = val.match(/\\/by-id\\/([^\\s]+)/)\n    return (match && match[1]) || undefined\n  }\n  if (name === 'manufacturer') {\n    return decodeHexEscape(val)\n  }\n  if (/^0x/.test(val)) {\n    return val.substr(2)\n  }\n  return val\n}\n\nfunction listLinux() {\n  return new Promise((resolve, reject) => {\n    const ports = []\n    const ude = childProcess.spawn('udevadm', ['info', '-e'])\n    const lines = ude.stdout.pipe(new Readline())\n    ude.on('close', code => code && reject(new Error(`Error listing ports udevadm exited with error code: ${code}`)))\n    ude.on('error', reject)\n    lines.on('error', reject)\n\n    let port = {}\n    let skipPort = false\n    lines.on('data', line => {\n      const lineType = line.slice(0, 1)\n      const data = line.slice(3)\n      // new port entry\n      if (lineType === 'P') {\n        port = {\n          manufacturer: undefined,\n          serialNumber: undefined,\n          pnpId: undefined,\n          locationId: undefined,\n          vendorId: undefined,\n          productId: undefined,\n        }\n        skipPort = false\n        return\n      }\n\n      if (skipPort) {\n        return\n      }\n\n      // Check dev name and save port if it matches flag to skip the rest of the data if not\n      if (lineType === 'N') {\n        if (checkPathOfDevice(data)) {\n          ports.push(port)\n        } else {\n          skipPort = true\n        }\n        return\n      }\n\n      // parse data about each port\n      if (lineType === 'E') {\n        const keyValue = data.match(/^(.+)=(.*)/)\n        if (!keyValue) {\n          return\n        }\n        const key = propName(keyValue[1])\n        if (!key) {\n          return\n        }\n        port[key] = propVal(key, keyValue[2])\n      }\n    })\n\n    lines.on('finish', () => resolve(ports))\n  })\n}\n\nmodule.exports = listLinux\n"]},"metadata":{},"sourceType":"script"}