{"ast":null,"code":"const fs = require('fs');\n\nconst debug = require('debug');\n\nconst logger = debug('serialport/bindings/unixRead');\n\nconst {\n  promisify\n} = require('util');\n\nconst readAsync = promisify(fs.read);\n\nconst readable = binding => {\n  return new Promise((resolve, reject) => {\n    binding.poller.once('readable', err => err ? reject(err) : resolve());\n  });\n};\n\nconst unixRead = async ({\n  binding,\n  buffer,\n  offset,\n  length,\n  fsReadAsync = readAsync\n}) => {\n  logger('Starting read');\n\n  if (!binding.isOpen) {\n    const err = new Error('Port is not open');\n    err.canceled = true;\n    throw err;\n  }\n\n  try {\n    const {\n      bytesRead\n    } = await fsReadAsync(binding.fd, buffer, offset, length, null);\n\n    if (bytesRead === 0) {\n      return unixRead({\n        binding,\n        buffer,\n        offset,\n        length,\n        fsReadAsync\n      });\n    }\n\n    logger('Finished read', bytesRead, 'bytes');\n    return {\n      bytesRead,\n      buffer\n    };\n  } catch (err) {\n    logger('read error', err);\n\n    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n      if (!binding.isOpen) {\n        const err = new Error('Port is not open');\n        err.canceled = true;\n        throw err;\n      }\n\n      logger('waiting for readable because of code:', err.code);\n      await readable(binding);\n      return unixRead({\n        binding,\n        buffer,\n        offset,\n        length,\n        fsReadAsync\n      });\n    }\n\n    const disconnectError = err.code === 'EBADF' || // Bad file number means we got closed\n    err.code === 'ENXIO' || // No such device or address probably usb disconnect\n    err.code === 'UNKNOWN' || err.errno === -1; // generic error\n\n    if (disconnectError) {\n      err.disconnect = true;\n      logger('disconnecting', err);\n    }\n\n    throw err;\n  }\n};\n\nmodule.exports = unixRead;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/bindings/lib/unix-read.js"],"names":["fs","require","debug","logger","promisify","readAsync","read","readable","binding","Promise","resolve","reject","poller","once","err","unixRead","buffer","offset","length","fsReadAsync","isOpen","Error","canceled","bytesRead","fd","code","disconnectError","errno","disconnect","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs')\nconst debug = require('debug')\nconst logger = debug('serialport/bindings/unixRead')\nconst { promisify } = require('util')\n\nconst readAsync = promisify(fs.read)\n\nconst readable = binding => {\n  return new Promise((resolve, reject) => {\n    binding.poller.once('readable', err => (err ? reject(err) : resolve()))\n  })\n}\n\nconst unixRead = async ({ binding, buffer, offset, length, fsReadAsync = readAsync }) => {\n  logger('Starting read')\n  if (!binding.isOpen) {\n    const err = new Error('Port is not open')\n    err.canceled = true\n    throw err\n  }\n\n  try {\n    const { bytesRead } = await fsReadAsync(binding.fd, buffer, offset, length, null)\n    if (bytesRead === 0) {\n      return unixRead({ binding, buffer, offset, length, fsReadAsync })\n    }\n    logger('Finished read', bytesRead, 'bytes')\n    return { bytesRead, buffer }\n  } catch (err) {\n    logger('read error', err)\n    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {\n      if (!binding.isOpen) {\n        const err = new Error('Port is not open')\n        err.canceled = true\n        throw err\n      }\n      logger('waiting for readable because of code:', err.code)\n      await readable(binding)\n      return unixRead({ binding, buffer, offset, length, fsReadAsync })\n    }\n\n    const disconnectError =\n      err.code === 'EBADF' || // Bad file number means we got closed\n      err.code === 'ENXIO' || // No such device or address probably usb disconnect\n      err.code === 'UNKNOWN' ||\n      err.errno === -1 // generic error\n\n    if (disconnectError) {\n      err.disconnect = true\n      logger('disconnecting', err)\n    }\n\n    throw err\n  }\n}\n\nmodule.exports = unixRead\n"]},"metadata":{},"sourceType":"script"}