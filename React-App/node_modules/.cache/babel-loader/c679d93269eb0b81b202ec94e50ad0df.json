{"ast":null,"code":"const {\n  Transform\n} = require('stream');\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n * @summary To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n * @extends Transform\n * @example\nconst SerialPort = require('serialport')\nconst Ready = require('@serialport/parser-ready')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Ready({ delimiter: 'READY' }))\nparser.on('ready', () => console.log('the ready byte sequence has been received'))\nparser.on('data', console.log) // all data after READY is received\n */\n\n\nclass ReadyParser extends Transform {\n  /**\n   *\n   * @param {object} options options for the parser\n   * @param {string|Buffer|array} options.delimiter data to look for before emitted \"ready\"\n   */\n  constructor(options = {}) {\n    if (options.delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object');\n    }\n\n    if (options.delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length');\n    }\n\n    super(options);\n    this.delimiter = Buffer.from(options.delimiter);\n    this.readOffset = 0;\n    this.ready = false;\n  }\n\n  _transform(chunk, encoding, cb) {\n    if (this.ready) {\n      this.push(chunk);\n      return cb();\n    }\n\n    const delimiter = this.delimiter;\n    let chunkOffset = 0;\n\n    while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n      if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n        this.readOffset++;\n      } else {\n        this.readOffset = 0;\n      }\n\n      chunkOffset++;\n    }\n\n    if (this.readOffset === delimiter.length) {\n      this.ready = true;\n      this.emit('ready');\n      const chunkRest = chunk.slice(chunkOffset);\n\n      if (chunkRest.length > 0) {\n        this.push(chunkRest);\n      }\n    }\n\n    cb();\n  }\n\n}\n\nmodule.exports = ReadyParser;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/parser-ready/lib/index.js"],"names":["Transform","require","ReadyParser","constructor","options","delimiter","undefined","TypeError","length","Buffer","from","readOffset","ready","_transform","chunk","encoding","cb","push","chunkOffset","emit","chunkRest","slice","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;AAEA;;;;;;;;;;;;;;AAYA,MAAMC,WAAN,SAA0BF,SAA1B,CAAoC;AAClC;;;;;AAKAG,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB,QAAIA,OAAO,CAACC,SAAR,KAAsBC,SAA1B,EAAqC;AACnC,YAAM,IAAIC,SAAJ,CAAc,wCAAd,CAAN;AACD;;AAED,QAAIH,OAAO,CAACC,SAAR,CAAkBG,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,YAAM,IAAID,SAAJ,CAAc,yCAAd,CAAN;AACD;;AAED,UAAMH,OAAN;AACA,SAAKC,SAAL,GAAiBI,MAAM,CAACC,IAAP,CAAYN,OAAO,CAACC,SAApB,CAAjB;AACA,SAAKM,UAAL,GAAkB,CAAlB;AACA,SAAKC,KAAL,GAAa,KAAb;AACD;;AAEDC,EAAAA,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,EAAlB,EAAsB;AAC9B,QAAI,KAAKJ,KAAT,EAAgB;AACd,WAAKK,IAAL,CAAUH,KAAV;AACA,aAAOE,EAAE,EAAT;AACD;;AACD,UAAMX,SAAS,GAAG,KAAKA,SAAvB;AACA,QAAIa,WAAW,GAAG,CAAlB;;AACA,WAAO,KAAKP,UAAL,GAAkBN,SAAS,CAACG,MAA5B,IAAsCU,WAAW,GAAGJ,KAAK,CAACN,MAAjE,EAAyE;AACvE,UAAIH,SAAS,CAAC,KAAKM,UAAN,CAAT,KAA+BG,KAAK,CAACI,WAAD,CAAxC,EAAuD;AACrD,aAAKP,UAAL;AACD,OAFD,MAEO;AACL,aAAKA,UAAL,GAAkB,CAAlB;AACD;;AACDO,MAAAA,WAAW;AACZ;;AACD,QAAI,KAAKP,UAAL,KAAoBN,SAAS,CAACG,MAAlC,EAA0C;AACxC,WAAKI,KAAL,GAAa,IAAb;AACA,WAAKO,IAAL,CAAU,OAAV;AACA,YAAMC,SAAS,GAAGN,KAAK,CAACO,KAAN,CAAYH,WAAZ,CAAlB;;AACA,UAAIE,SAAS,CAACZ,MAAV,GAAmB,CAAvB,EAA0B;AACxB,aAAKS,IAAL,CAAUG,SAAV;AACD;AACF;;AACDJ,IAAAA,EAAE;AACH;;AA7CiC;;AAgDpCM,MAAM,CAACC,OAAP,GAAiBrB,WAAjB","sourcesContent":["const { Transform } = require('stream')\n\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n * @summary To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n * @extends Transform\n * @example\nconst SerialPort = require('serialport')\nconst Ready = require('@serialport/parser-ready')\nconst port = new SerialPort('/dev/tty-usbserial1')\nconst parser = port.pipe(new Ready({ delimiter: 'READY' }))\nparser.on('ready', () => console.log('the ready byte sequence has been received'))\nparser.on('data', console.log) // all data after READY is received\n */\nclass ReadyParser extends Transform {\n  /**\n   *\n   * @param {object} options options for the parser\n   * @param {string|Buffer|array} options.delimiter data to look for before emitted \"ready\"\n   */\n  constructor(options = {}) {\n    if (options.delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object')\n    }\n\n    if (options.delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length')\n    }\n\n    super(options)\n    this.delimiter = Buffer.from(options.delimiter)\n    this.readOffset = 0\n    this.ready = false\n  }\n\n  _transform(chunk, encoding, cb) {\n    if (this.ready) {\n      this.push(chunk)\n      return cb()\n    }\n    const delimiter = this.delimiter\n    let chunkOffset = 0\n    while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n      if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n        this.readOffset++\n      } else {\n        this.readOffset = 0\n      }\n      chunkOffset++\n    }\n    if (this.readOffset === delimiter.length) {\n      this.ready = true\n      this.emit('ready')\n      const chunkRest = chunk.slice(chunkOffset)\n      if (chunkRest.length > 0) {\n        this.push(chunkRest)\n      }\n    }\n    cb()\n  }\n}\n\nmodule.exports = ReadyParser\n"]},"metadata":{},"sourceType":"script"}