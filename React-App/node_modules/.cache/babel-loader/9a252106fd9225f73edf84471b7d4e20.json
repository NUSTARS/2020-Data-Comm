{"ast":null,"code":"// -------------------------------------------------------\n// deep proxy\n// -------------------------------------------------------\nconst OWN_KEYS_SYMBOL = Symbol();\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\nconst TRACK_OBJECT_PROPERTY = 't';\nconst AFFECTED_PROPERTY = 'a';\nconst RECORD_USAGE_PROPERTY = 'r';\nconst RECORD_OBJECT_AS_USED_PROPERTY = 'u';\nconst ORIGINAL_OBJECT_PROPERTY = 'o';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst GLOBAL_OBJECT = Object;\nconst GLOBAL_ARRAY = Array;\nconst GLOBAL_REFLECT = Reflect; // check if obj is a plain object or an array\n\nconst isPlainObject = obj => {\n  try {\n    const proto = GLOBAL_OBJECT.getPrototypeOf(obj);\n    return proto === GLOBAL_OBJECT.prototype || proto === GLOBAL_ARRAY.prototype;\n  } catch (e) {\n    return false;\n  }\n}; // copy obj if frozen\n\n\nconst unfreeze = obj => {\n  if (!GLOBAL_OBJECT.isFrozen(obj)) return obj;\n\n  if (GLOBAL_ARRAY.isArray(obj)) {\n    return GLOBAL_ARRAY.from(obj);\n  }\n\n  return GLOBAL_OBJECT.assign({}, obj);\n};\n\nconst createProxyHandler = () => ({\n  [RECORD_USAGE_PROPERTY](key) {\n    if (this[TRACK_OBJECT_PROPERTY]) return;\n    let used = this[AFFECTED_PROPERTY].get(this[ORIGINAL_OBJECT_PROPERTY]);\n\n    if (!used) {\n      used = new Set();\n      this[AFFECTED_PROPERTY].set(this[ORIGINAL_OBJECT_PROPERTY], used);\n    }\n\n    used.add(key);\n  },\n\n  [RECORD_OBJECT_AS_USED_PROPERTY]() {\n    this[TRACK_OBJECT_PROPERTY] = true;\n    this[AFFECTED_PROPERTY].delete(this[ORIGINAL_OBJECT_PROPERTY]);\n  },\n\n  get(target, key) {\n    if (key === GET_ORIGINAL_SYMBOL) {\n      return this[ORIGINAL_OBJECT_PROPERTY];\n    }\n\n    this[RECORD_USAGE_PROPERTY](key); // eslint-disable-next-line no-use-before-define, @typescript-eslint/no-use-before-define\n\n    return createDeepProxy(target[key], this[AFFECTED_PROPERTY], this[PROXY_CACHE_PROPERTY]);\n  },\n\n  has(target, key) {\n    if (key === TRACK_MEMO_SYMBOL) {\n      this[RECORD_OBJECT_AS_USED_PROPERTY]();\n      return true;\n    } // LIMITATION:\n    // We simply record the same as get.\n    // This means { a: {} } and { a: {} } is detected as changed,\n    // if 'a' in obj is handled.\n\n\n    this[RECORD_USAGE_PROPERTY](key);\n    return key in target;\n  },\n\n  ownKeys(target) {\n    this[RECORD_USAGE_PROPERTY](OWN_KEYS_SYMBOL);\n    return GLOBAL_REFLECT.ownKeys(target);\n  }\n\n});\n\nexport const createDeepProxy = (obj, affected, proxyCache) => {\n  if (!isPlainObject(obj)) return obj;\n  const origObj = obj[GET_ORIGINAL_SYMBOL]; // unwrap proxy\n\n  if (origObj) obj = origObj;\n  let proxyHandler = proxyCache && proxyCache.get(obj);\n\n  if (!proxyHandler) {\n    proxyHandler = createProxyHandler();\n    proxyHandler[PROXY_PROPERTY] = new Proxy(unfreeze(obj), proxyHandler);\n    proxyHandler[ORIGINAL_OBJECT_PROPERTY] = obj;\n    proxyHandler[TRACK_OBJECT_PROPERTY] = false; // for trackMemo\n\n    if (proxyCache) {\n      proxyCache.set(obj, proxyHandler);\n    }\n  }\n\n  proxyHandler[AFFECTED_PROPERTY] = affected;\n  proxyHandler[PROXY_CACHE_PROPERTY] = proxyCache;\n  return proxyHandler[PROXY_PROPERTY];\n};\n\nconst isOwnKeysChanged = (origObj, nextObj) => {\n  const origKeys = GLOBAL_REFLECT.ownKeys(origObj);\n  const nextKeys = GLOBAL_REFLECT.ownKeys(nextObj);\n  return origKeys.length !== nextKeys.length || origKeys.some((k, i) => k !== nextKeys[i]);\n};\n\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED =\n/*   */\n0b00001;\nexport const MODE_IGNORE_REF_EQUALITY =\n/*              */\n0b00010;\nconst IN_DEEP_SHIFT = 2;\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP = MODE_ASSUME_UNCHANGED_IF_UNAFFECTED << IN_DEEP_SHIFT;\nexport const MODE_IGNORE_REF_EQUALITY_IN_DEEP = MODE_IGNORE_REF_EQUALITY << IN_DEEP_SHIFT;\nexport const isDeepChanged = (origObj, nextObj, affected, cache, mode) => {\n  if (origObj === nextObj && (mode & MODE_IGNORE_REF_EQUALITY) === 0) return false;\n  if (typeof origObj !== 'object' || origObj === null) return true;\n  if (typeof nextObj !== 'object' || nextObj === null) return true;\n  const used = affected.get(origObj);\n  if (!used) return (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    const hit = cache.get(origObj);\n\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    } // for object with cycles (CHANGED_PROPERTY is `undefined`)\n\n\n    cache.set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj\n    });\n  }\n\n  let changed = null; // eslint-disable-next-line no-restricted-syntax\n\n  for (const key of used) {\n    const c = key === OWN_KEYS_SYMBOL ? isOwnKeysChanged(origObj, nextObj) : isDeepChanged(origObj[key], nextObj[key], affected, cache, mode >>> IN_DEEP_SHIFT << IN_DEEP_SHIFT | mode >>> IN_DEEP_SHIFT);\n    if (c === true || c === false) changed = c;\n    if (changed) break;\n  }\n\n  if (changed === null) changed = (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    cache.set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: changed\n    });\n  }\n\n  return changed;\n}; // explicitly track object with memo\n\nexport const trackMemo = obj => {\n  if (isPlainObject(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n\n  return false;\n}; // get original object from proxy\n\nexport const getUntrackedObject = obj => {\n  if (isPlainObject(obj)) {\n    return obj[GET_ORIGINAL_SYMBOL] || null;\n  }\n\n  return null;\n};","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/react-tracked/src/deepProxy.js"],"names":["OWN_KEYS_SYMBOL","Symbol","TRACK_MEMO_SYMBOL","GET_ORIGINAL_SYMBOL","TRACK_OBJECT_PROPERTY","AFFECTED_PROPERTY","RECORD_USAGE_PROPERTY","RECORD_OBJECT_AS_USED_PROPERTY","ORIGINAL_OBJECT_PROPERTY","PROXY_PROPERTY","PROXY_CACHE_PROPERTY","NEXT_OBJECT_PROPERTY","CHANGED_PROPERTY","GLOBAL_OBJECT","Object","GLOBAL_ARRAY","Array","GLOBAL_REFLECT","Reflect","isPlainObject","obj","proto","getPrototypeOf","prototype","e","unfreeze","isFrozen","isArray","from","assign","createProxyHandler","key","used","get","Set","set","add","delete","target","createDeepProxy","has","ownKeys","affected","proxyCache","origObj","proxyHandler","Proxy","isOwnKeysChanged","nextObj","origKeys","nextKeys","length","some","k","i","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED","MODE_IGNORE_REF_EQUALITY","IN_DEEP_SHIFT","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP","MODE_IGNORE_REF_EQUALITY_IN_DEEP","isDeepChanged","cache","mode","hit","changed","c","trackMemo","getUntrackedObject"],"mappings":"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","sourcesContent":["// -------------------------------------------------------\n// deep proxy\n// -------------------------------------------------------\n\nconst OWN_KEYS_SYMBOL = Symbol();\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\nconst TRACK_OBJECT_PROPERTY = 't';\nconst AFFECTED_PROPERTY = 'a';\nconst RECORD_USAGE_PROPERTY = 'r';\nconst RECORD_OBJECT_AS_USED_PROPERTY = 'u';\nconst ORIGINAL_OBJECT_PROPERTY = 'o';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\n\nconst GLOBAL_OBJECT = Object;\nconst GLOBAL_ARRAY = Array;\nconst GLOBAL_REFLECT = Reflect;\n\n// check if obj is a plain object or an array\nconst isPlainObject = (obj) => {\n  try {\n    const proto = GLOBAL_OBJECT.getPrototypeOf(obj);\n    return proto === GLOBAL_OBJECT.prototype || proto === GLOBAL_ARRAY.prototype;\n  } catch (e) {\n    return false;\n  }\n};\n\n// copy obj if frozen\nconst unfreeze = (obj) => {\n  if (!GLOBAL_OBJECT.isFrozen(obj)) return obj;\n  if (GLOBAL_ARRAY.isArray(obj)) {\n    return GLOBAL_ARRAY.from(obj);\n  }\n  return GLOBAL_OBJECT.assign({}, obj);\n};\n\nconst createProxyHandler = () => ({\n  [RECORD_USAGE_PROPERTY](key) {\n    if (this[TRACK_OBJECT_PROPERTY]) return;\n    let used = this[AFFECTED_PROPERTY].get(this[ORIGINAL_OBJECT_PROPERTY]);\n    if (!used) {\n      used = new Set();\n      this[AFFECTED_PROPERTY].set(this[ORIGINAL_OBJECT_PROPERTY], used);\n    }\n    used.add(key);\n  },\n  [RECORD_OBJECT_AS_USED_PROPERTY]() {\n    this[TRACK_OBJECT_PROPERTY] = true;\n    this[AFFECTED_PROPERTY].delete(this[ORIGINAL_OBJECT_PROPERTY]);\n  },\n  get(target, key) {\n    if (key === GET_ORIGINAL_SYMBOL) {\n      return this[ORIGINAL_OBJECT_PROPERTY];\n    }\n    this[RECORD_USAGE_PROPERTY](key);\n    // eslint-disable-next-line no-use-before-define, @typescript-eslint/no-use-before-define\n    return createDeepProxy(target[key], this[AFFECTED_PROPERTY], this[PROXY_CACHE_PROPERTY]);\n  },\n  has(target, key) {\n    if (key === TRACK_MEMO_SYMBOL) {\n      this[RECORD_OBJECT_AS_USED_PROPERTY]();\n      return true;\n    }\n    // LIMITATION:\n    // We simply record the same as get.\n    // This means { a: {} } and { a: {} } is detected as changed,\n    // if 'a' in obj is handled.\n    this[RECORD_USAGE_PROPERTY](key);\n    return key in target;\n  },\n  ownKeys(target) {\n    this[RECORD_USAGE_PROPERTY](OWN_KEYS_SYMBOL);\n    return GLOBAL_REFLECT.ownKeys(target);\n  },\n});\n\nexport const createDeepProxy = (obj, affected, proxyCache) => {\n  if (!isPlainObject(obj)) return obj;\n  const origObj = obj[GET_ORIGINAL_SYMBOL]; // unwrap proxy\n  if (origObj) obj = origObj;\n  let proxyHandler = proxyCache && proxyCache.get(obj);\n  if (!proxyHandler) {\n    proxyHandler = createProxyHandler();\n    proxyHandler[PROXY_PROPERTY] = new Proxy(unfreeze(obj), proxyHandler);\n    proxyHandler[ORIGINAL_OBJECT_PROPERTY] = obj;\n    proxyHandler[TRACK_OBJECT_PROPERTY] = false; // for trackMemo\n    if (proxyCache) {\n      proxyCache.set(obj, proxyHandler);\n    }\n  }\n  proxyHandler[AFFECTED_PROPERTY] = affected;\n  proxyHandler[PROXY_CACHE_PROPERTY] = proxyCache;\n  return proxyHandler[PROXY_PROPERTY];\n};\n\nconst isOwnKeysChanged = (origObj, nextObj) => {\n  const origKeys = GLOBAL_REFLECT.ownKeys(origObj);\n  const nextKeys = GLOBAL_REFLECT.ownKeys(nextObj);\n  return origKeys.length !== nextKeys.length\n    || origKeys.some((k, i) => k !== nextKeys[i]);\n};\n\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED = /*   */ 0b00001;\nexport const MODE_IGNORE_REF_EQUALITY = /*              */ 0b00010;\n\nconst IN_DEEP_SHIFT = 2;\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP = (\n  MODE_ASSUME_UNCHANGED_IF_UNAFFECTED << IN_DEEP_SHIFT\n);\nexport const MODE_IGNORE_REF_EQUALITY_IN_DEEP = (\n  MODE_IGNORE_REF_EQUALITY << IN_DEEP_SHIFT\n);\n\nexport const isDeepChanged = (\n  origObj,\n  nextObj,\n  affected,\n  cache,\n  mode,\n) => {\n  if (origObj === nextObj && (mode & MODE_IGNORE_REF_EQUALITY) === 0) return false;\n  if (typeof origObj !== 'object' || origObj === null) return true;\n  if (typeof nextObj !== 'object' || nextObj === null) return true;\n  const used = affected.get(origObj);\n  if (!used) return (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    const hit = cache.get(origObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles (CHANGED_PROPERTY is `undefined`)\n    cache.set(origObj, { [NEXT_OBJECT_PROPERTY]: nextObj });\n  }\n  let changed = null;\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key of used) {\n    const c = key === OWN_KEYS_SYMBOL ? isOwnKeysChanged(origObj, nextObj)\n      : isDeepChanged(\n        origObj[key],\n        nextObj[key],\n        affected,\n        cache,\n        ((mode >>> IN_DEEP_SHIFT) << IN_DEEP_SHIFT) | (mode >>> IN_DEEP_SHIFT),\n      );\n    if (c === true || c === false) changed = c;\n    if (changed) break;\n  }\n  if (changed === null) changed = (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    cache.set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: changed,\n    });\n  }\n  return changed;\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj) => {\n  if (isPlainObject(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n// get original object from proxy\nexport const getUntrackedObject = (obj) => {\n  if (isPlainObject(obj)) {\n    return obj[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n"]},"metadata":{},"sourceType":"module"}