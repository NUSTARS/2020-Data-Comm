{"ast":null,"code":"const {\n  Transform\n} = require('stream');\n/**\n * Parse the CCTalk protocol\n * @extends Transform\n * @summary A transform stream that emits CCTalk packets as they are received.\n * @example\nconst SerialPort = require('serialport')\nconst CCTalk = require('@serialport/parser-cctalk')\nconst port = new SerialPort('/dev/ttyUSB0')\nconst parser = port.pipe(new CCtalk())\nparser.on('data', console.log)\n */\n\n\nclass CCTalkParser extends Transform {\n  constructor(maxDelayBetweenBytesMs = 50) {\n    super();\n    this.array = [];\n    this.cursor = 0;\n    this.lastByteFetchTime = 0;\n    this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs;\n  }\n\n  _transform(buffer, _, cb) {\n    if (this.maxDelayBetweenBytesMs > 0) {\n      const now = Date.now();\n\n      if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {\n        this.array = [];\n        this.cursor = 0;\n      }\n\n      this.lastByteFetchTime = now;\n    }\n\n    this.cursor += buffer.length; // TODO: Better Faster es7 no supported by node 4\n    // ES7 allows directly push [...buffer]\n    // this.array = this.array.concat(Array.from(buffer)) //Slower ?!?\n\n    Array.from(buffer).map(byte => this.array.push(byte));\n\n    while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {\n      // full frame accumulated\n      // copy command from the array\n      const FullMsgLength = this.array[1] + 5;\n      const frame = Buffer.from(this.array.slice(0, FullMsgLength)); // Preserve Extra Data\n\n      this.array = this.array.slice(frame.length, this.array.length);\n      this.cursor -= FullMsgLength;\n      this.push(frame);\n    }\n\n    cb();\n  }\n\n}\n\nmodule.exports = CCTalkParser;","map":{"version":3,"sources":["/Users/Nathan/Desktop/data-comm-ui/node_modules/@serialport/parser-cctalk/lib/index.js"],"names":["Transform","require","CCTalkParser","constructor","maxDelayBetweenBytesMs","array","cursor","lastByteFetchTime","_transform","buffer","_","cb","now","Date","length","Array","from","map","byte","push","FullMsgLength","frame","Buffer","slice","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;AAEA;;;;;;;;;;;;;AAWA,MAAMC,YAAN,SAA2BF,SAA3B,CAAqC;AACnCG,EAAAA,WAAW,CAACC,sBAAsB,GAAG,EAA1B,EAA8B;AACvC;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,iBAAL,GAAyB,CAAzB;AACA,SAAKH,sBAAL,GAA8BA,sBAA9B;AACD;;AACDI,EAAAA,UAAU,CAACC,MAAD,EAASC,CAAT,EAAYC,EAAZ,EAAgB;AACxB,QAAI,KAAKP,sBAAL,GAA8B,CAAlC,EAAqC;AACnC,YAAMQ,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;;AACA,UAAIA,GAAG,GAAG,KAAKL,iBAAX,GAA+B,KAAKH,sBAAxC,EAAgE;AAC9D,aAAKC,KAAL,GAAa,EAAb;AACA,aAAKC,MAAL,GAAc,CAAd;AACD;;AACD,WAAKC,iBAAL,GAAyBK,GAAzB;AACD;;AAED,SAAKN,MAAL,IAAeG,MAAM,CAACK,MAAtB,CAVwB,CAWxB;AACA;AACA;;AACAC,IAAAA,KAAK,CAACC,IAAN,CAAWP,MAAX,EAAmBQ,GAAnB,CAAuBC,IAAI,IAAI,KAAKb,KAAL,CAAWc,IAAX,CAAgBD,IAAhB,CAA/B;;AACA,WAAO,KAAKZ,MAAL,GAAc,CAAd,IAAmB,KAAKA,MAAL,IAAe,KAAKD,KAAL,CAAW,CAAX,IAAgB,CAAzD,EAA4D;AAC1D;AACA;AACA,YAAMe,aAAa,GAAG,KAAKf,KAAL,CAAW,CAAX,IAAgB,CAAtC;AAEA,YAAMgB,KAAK,GAAGC,MAAM,CAACN,IAAP,CAAY,KAAKX,KAAL,CAAWkB,KAAX,CAAiB,CAAjB,EAAoBH,aAApB,CAAZ,CAAd,CAL0D,CAM1D;;AACA,WAAKf,KAAL,GAAa,KAAKA,KAAL,CAAWkB,KAAX,CAAiBF,KAAK,CAACP,MAAvB,EAA+B,KAAKT,KAAL,CAAWS,MAA1C,CAAb;AACA,WAAKR,MAAL,IAAec,aAAf;AACA,WAAKD,IAAL,CAAUE,KAAV;AACD;;AACDV,IAAAA,EAAE;AACH;;AAnCkC;;AAsCrCa,MAAM,CAACC,OAAP,GAAiBvB,YAAjB","sourcesContent":["const { Transform } = require('stream')\n\n/**\n * Parse the CCTalk protocol\n * @extends Transform\n * @summary A transform stream that emits CCTalk packets as they are received.\n * @example\nconst SerialPort = require('serialport')\nconst CCTalk = require('@serialport/parser-cctalk')\nconst port = new SerialPort('/dev/ttyUSB0')\nconst parser = port.pipe(new CCtalk())\nparser.on('data', console.log)\n */\nclass CCTalkParser extends Transform {\n  constructor(maxDelayBetweenBytesMs = 50) {\n    super()\n    this.array = []\n    this.cursor = 0\n    this.lastByteFetchTime = 0\n    this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs\n  }\n  _transform(buffer, _, cb) {\n    if (this.maxDelayBetweenBytesMs > 0) {\n      const now = Date.now()\n      if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {\n        this.array = []\n        this.cursor = 0\n      }\n      this.lastByteFetchTime = now\n    }\n\n    this.cursor += buffer.length\n    // TODO: Better Faster es7 no supported by node 4\n    // ES7 allows directly push [...buffer]\n    // this.array = this.array.concat(Array.from(buffer)) //Slower ?!?\n    Array.from(buffer).map(byte => this.array.push(byte))\n    while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {\n      // full frame accumulated\n      // copy command from the array\n      const FullMsgLength = this.array[1] + 5\n\n      const frame = Buffer.from(this.array.slice(0, FullMsgLength))\n      // Preserve Extra Data\n      this.array = this.array.slice(frame.length, this.array.length)\n      this.cursor -= FullMsgLength\n      this.push(frame)\n    }\n    cb()\n  }\n}\n\nmodule.exports = CCTalkParser\n"]},"metadata":{},"sourceType":"script"}